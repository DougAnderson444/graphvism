//! Convenience wrapper that sets up wasmtime and initiates the graphvizm component.
mod error;
pub use error::GraphvizmError;

use wasmtime::{
    Config, Engine, Store,
    component::{Component, Linker},
};
use wasmtime_wasi::{ResourceTable, WasiCtx, WasiCtxView, WasiView};

// Include the bindings generated by `build.rs`.
// This will define the `Viz` world (and the `Viz` struct).
include!(concat!(env!("OUT_DIR"), "/bindings.rs"));

struct MyState {
    wasi: WasiCtx,
    table: ResourceTable,
}

impl WasiView for MyState {
    fn ctx(&mut self) -> WasiCtxView<'_> {
        WasiCtxView {
            ctx: &mut self.wasi,
            table: &mut self.table,
        }
    }
}

#[derive(Clone)]
pub struct Graphvizm {
    engine: Engine,
    component: Component,
    linker: Linker<MyState>, // reuse linker setup
}

impl Default for Graphvizm {
    fn default() -> Self {
        Self::new().expect("Failed to initialize Graphvizm")
    }
}

impl Graphvizm {
    pub fn new() -> Result<Self, GraphvizmError> {
        let mut config = Config::new();
        config.wasm_component_model(true);
        let engine = Engine::new(&config)?;

        let component_bytes = include_bytes!(concat!(env!("OUT_DIR"), "/viz.wasm"));
        let component = Component::from_binary(&engine, component_bytes)?;

        let mut linker = Linker::new(&engine);
        wasmtime_wasi::p2::add_to_linker_sync(&mut linker)?;

        Ok(Self {
            engine,
            component,
            linker,
        })
    }

    pub fn render_dot(&self, dot: &str) -> Result<String, GraphvizmError> {
        let wasi = WasiCtx::builder().inherit_stdio().inherit_args().build();
        let state = MyState {
            wasi,
            table: ResourceTable::new(),
        };
        let mut store = Store::new(&self.engine, state);

        let viz = Viz::instantiate(&mut store, &self.component, &self.linker)?;
        let iface = &viz.interface0;
        let ctx = iface.call_create_context(&mut store)?;

        match iface.call_render_dot(&mut store, ctx, dot, "dot", "svg") {
            Ok(Ok(svg)) => Ok(svg),
            Ok(Err(err_str)) => Err(GraphvizmError::Render(err_str)),
            Err(e) => Err(GraphvizmError::Wasmtime(e)),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let graphvizm = Graphvizm::default();
        let dot = r#"digraph { a -> b }"#;
        let svg = graphvizm.render_dot(dot).unwrap();
        assert!(svg.contains("<svg"));
        assert!(svg.contains("<title>a</title>"));
        assert!(svg.contains("<title>b</title>"));
        assert!(svg.contains("<title>a&#45;&gt;b</title>"));
    }
}
